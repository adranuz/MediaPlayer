{"id":"ejercicios/prototype.html","dependencies":[{"name":"/Users/saaib/Documents/Dev/MediaPlayer/package.json","includedInParent":true,"mtime":1596000178698}],"generated":{"html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Prototype</title>\n</head>\n<body>\n  <a href=\"/ejercicios/\">Go back</a>\n  <p><em>Abre la consola</em></p>\n\n  <script>/*\n    En JS el tipo de dato rey es el objeto\n\n    En JS las clases no existen, lo que mas cercano que tenemos son los objetos con prototype mediante el cual manejamos la herencia\n\n    Todos los objetos heredan de un prototype, que a su vez hereda de otro prototype\n\n    La palabra 'new' es la que declara la herencia\n    */\n// object literal: objeto común y corriente: lista de keys y values\n\n/*--Es un poco ineficiente porque los dos objetos son muy similares y para crear otro hay que escribirlo totalmente*/\n\n/*const zelda = { name: 'Zelda' } //objeto cualquiera\nzelda.saludar = function () { //agregando otro espacio en el objeto\n  console.log(`hola soy ${this.name}`)\n}\nzelda.saludar()\n const link = { name: 'Link' } \nlink.saludar = function () {\n  console.log(`hola soy ${this.name}`)\n}\nlink.saludar()*/\n//--function constructor de Heros\n\n/*function Hero(name) {\n  const hero = { //objeto creado dentro de la funcion \n    name: name\n  }\n  hero.saludar = function() { //nuevo espacio alojado en hero\n    console.log(`hola soy ${this.name}`)\n  }\n  return hero //retornamos el objeto creado\n}\n\n//crea los objetos que heredan sus propiedades de la funcion Hero\nconst zelda =  Hero('Zelda')\nconst link = new Hero('Link')\n//corremos el metodo que heredaron\nzelda.saludar()\nlink.saludar()\nconsole.log(zelda) //aqui se ve que contiene el objeto*/\n//objeto que promete tener la coleccion de metodos\n\n/*const heroMethods = { //objeto con los metodos\n  saludar: function() {\n    console.log(`Hola soy ${this.name}`)\n  }\n}\nfunction Hero(name) {\n  const hero = { //objeto creado dentro de la funcion \n    name: name\n  }\n  hero.saludar = heroMethods.saludar //en lugar de crear la funcion solo la referenciamos al objeto que la contiene ¿pa que?\n  return hero //retornamos el objeto creado\n}\n//crea los objetos que heredan sus propiedades de la funcion Hero\nconst zelda =  Hero('Zelda')\nconst link = new Hero('Link')\n//corremos el metodo que heredaron\nzelda.saludar()\nlink.saludar()*/\n//--Crear un objeto mediante Object.create\n//Object.create crea un nuevo objeto a partir de otro\n//const newObject = Object.create(object)\n\n/*const heroMethods = { //objeto con los metodos\n  saludar: function() {\n    console.log(`Hola soy ${this.name}`)\n  }\n}\nfunction Hero(name) {\n  //creamos un objeto con todas las propiedades de heroMethods\n  const hero = Object.create(heroMethods)\n  hero.name = name //de esta manera incluimos a name, que aqui le damos valor\n  return hero //retornamos el objeto creado\n}\n//crea los objetos que heredan sus propiedades de la funcion Hero\nconst zelda =  Hero('Zelda')\nconst link = new Hero('Link')\n//corremos el metodo que heredaron\nzelda.saludar()\nlink.saludar()\n //--entendiendo a Object.create()\n//desde consola\nconst newHero = Object.create(heroMethods)\nnewHero.saludar //obtenemos la sintaxis del metodo\nnewHero\n//vemos que solo tiene un objeto __proto__, pero porque no tiene saludar? si abrimos proto veremos que si lo tiene, pero tiene otro __proto__*/\n//--ponemos los metodos de hero en su objeto prototype, que es un metodo que tienen todos los objetos, por lo tanto hero tambien\n//inicialmente prototype es un objeto vacio que solo contiene el constructor\n\n/*function Hero(name) {\n  //crea un objeto a partir del prototype al que le podemos ir agregando mas cosas\n  const hero = Object.create(Hero.prototype)\n  hero.name = name //de esta manera incluimos a name, que aqui le damos valor\n  return hero //retornamos el objeto creado\n}\nHero.prototype.saludar = function() {\n  console.log(`Hola soy ${this.name}`)\n}\n//crea los objetos que heredan sus propiedades de la funcion Hero\nconst zelda =  Hero('Zelda')\nconst link = new Hero('Link')\n//corremos el metodo que heredaron\nzelda.saludar()\nlink.saludar()*/\n//--que hace new? azucar sintactica\n//nos hace implicitos el agregar metodos por medio del prototype\n//nos hace usar this como valores de la instancia\n//hace el return implicito por medio del objeto prototipal\nfunction Hero(name) {\n  //const hero = Object.create(Hero.prototype) implicito por new\n  this.name = name; //de esta manera incluimos a name, que aqui le damos valor\n  //return hero //implicito por new\n}\n\nHero.prototype.saludar = function () {\n  console.log(\"Hola soy \".concat(this.name));\n}; //crea los objetos que heredan sus propiedades de la funcion Hero\n//ademas que new hace que hereden del prototype\n//es decir que los metodos sean obtenidos en this\n\n\nvar zelda = new Hero('Zelda');\nvar link = new Hero('Link'); //corremos el metodo que heredaron\n\nzelda.saludar();\nlink.saludar();\n/*Al final \ntenemos que al inicializar una variable con new la estamos instanciando como objeto que maneja el this y que maneja propiedades como metodos y variables a partir de su objeto prototype\n Por lo tanto Objetos que pueden heredad sus propiedades a variables y otros objetos\n*/</script>\n</body>\n</html>"},"sourceMaps":null,"error":null,"hash":"1dd4c4be9901c9ed81cdb4637088d5a0","cacheData":{"env":{}}}